[{"categories":["Java基础"],"content":"Java反射的一些概念","date":"2020-09-17","objectID":"/posts/reflect/reflect/","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"反射 反射：将类的各个组成部分封装为其他对象，就是反射机制 ​ 好处： ​ 1、可以在程序的运行过程中，操作这些对象 ​ 2、可以解耦，提高程序的可扩展性 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:0","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"获取class对象的方式 class.forName(“全类名”)：将字节码文件加载进内存，返回class对象 ​ 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 ​ 多用于参数传递 对象.getClass：getClass()方法在Object类中定义的 ​ 多用于对象的获取字节码的方式 结论：统一字节码文件在一次程序运行过程中只会加载一次，三种方式获取的Class对象都是同一个 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:1","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"Class对象的功能 获取功能 获取成员变量 Class\u003cUser\u003e userClass = User.class; Field[] fields = userClass.getFields(); //只获取public修饰的成员变量 Field name = userClass.getField(\"name\"); Field[] declaredFields = userClass.getDeclaredFields();//获取所有成员变量，不考虑修饰符 Field name1 = userClass.getDeclaredField(\"name\"); User user = new User(); name1.setAccessible(true); //忽略访问符权限修饰符的安全检查，暴力反射 name1.set(user,\"张三\"); //设值 name1.get(user); //取值 获取构造方法 Class\u003cUser\u003e userClass = User.class; Constructor\u003c?\u003e[] constructors = userClass.getConstructors(); Constructor\u003cUser\u003e constructor = userClass.getConstructor(String.class, Integer.class, Date.class); User user = constructor.newInstance(\"张三\", 20, new Date()); //创建对象 创建对象 T newInstance(Object… initargs) 获取成员方法 Class\u003cUser\u003e userClass = User.class; Method[] methods = userClass.getMethods(); Method setName = userClass.getMethod(\"setName\", String.class); User user = userClass.newInstance(); getName.invoke(user,\"张三\"); //执行该方法 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:2","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["JVM"],"content":"emmm....","date":"2020-09-16","objectID":"/posts/first_post/","tags":["JVM"],"title":"intern()方法的作用","uri":"/posts/first_post/"},{"categories":["JVM"],"content":"intern() 如果字符串常量池中没有对应的字符串的话，则在常量池中生成，并将引用地址改为常量池。如果存在就返回字符串， 保证变量s指向的是字符串常量池中的数据（另一种方式String s = “abc”） String s = new String(\"1\"); s.intern(); //常量池中已经存在\"1\"，s还是指向堆中的对象 String s2 = \"1\"; System.out.println(s == s2); //jdk6:false jdk7/jdk8:false String s3 = new String(\"1\") + new String(\"1\"); s3.intern(); //常量池中不存在\"11\"，生成后s3指向常量池 String s4 = \"11\"; System.out.println(s3 == s4); //jdk6:false jdk7/jdk8:true 题目1：new String(\"ab\")会创建几个对象 两个对象，看字节码就知道了 一个对象是：new关键字在堆空间中创建的 另一个对象是：字符串常量池中的对象 题目2：new String(\"a\") + new String(\"b\")会创建几个对象 对象1：new StringBuilder() 对象2：new String() 对象3：常量池中的\"a\" 对象4：new String() 对象5：常量池中的\"b\" StringBuilder的toString方法生成对象6 对象6：new String(\"ab\") toString()的调用，在字符串常量池中，没有生成\"ab\" ","date":"2020-09-16","objectID":"/posts/first_post/:1:0","tags":["JVM"],"title":"intern()方法的作用","uri":"/posts/first_post/"}]