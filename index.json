[{"categories":[],"content":"分布式缓存 ","date":"2020-12-11","objectID":"/posts/redis/redissonandspringcache/redissonandspringcache/:1:0","tags":["Redis","分布式"],"title":"关于Redis分布式锁和缓存一致性理解","uri":"/posts/redis/redissonandspringcache/redissonandspringcache/"},{"categories":[],"content":"Redis分布式锁 先来看一段SpringBoot整合Redis的代码 public String getInfo() { // 缓存逻辑 String info = stringRedisTemplate.opsForValue().get(\"info\"); if (StringUtils.isEmpty(info)) { System.out.println(\"缓存未命中,查询数据库\"); return getInfoFromDB(); } System.out.println(\"缓存命中\"); return info; } 很明显并发场景下会发生缓存击穿（大量请求同时查询一个刚好过期的数据），于是加把锁 public String getInfoWithLocalLock() { // 缓存逻辑 synchronized (this) { String info = stringRedisTemplate.opsForValue().get(\"info\"); if (StringUtils.isEmpty(info)) { System.out.println(\"缓存未命中,查询数据库\"); return getInfoFromDB(); } System.out.println(\"缓存命中\"); return info; } } 但是在分布式下，本地锁并不能锁住其他的相同服务，可以在Redis中保存一个key作为分布式锁，保存为获取锁，删除为释放锁。 public String getInfoFromDbWithRedisLock() { //创建分布式锁不设置唯一标识 String uuid = UUID.randomUUID().toString(); Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(\"lock\", \"uuid\", 300, TimeUnit.SECONDS); if (lock) { String info = \"\"; try { //执行业务逻辑 info = getInfoFromDB(); } finally { //删除锁 stringRedisTemplate.delete(\"lock\"); String lock1 = stringRedisTemplate.opsForValue().get(\"lock\"); if (uuid.equals(lock1)) { //删除自己的锁 stringRedisTemplate.delete(\"lock\"); } } return info; } else { System.out.println(\"分布式锁获取失败，等待重试\"); TimeUnit.MILLISECONDS.sleep(100); return getCatalogJsonFromDBWithRedisLock(); } } 如果在加锁之后，释放锁之前服务器突然断电，则不会释放锁，其他服务则会发生死锁。所以我们需要给锁设置一个过期时间。 有了过期时间之后，又出现了一个新的问题，当执行到uuid.equals(lock1)时这把锁刚好过期，这时候下一个请求获得了锁并保存了的key立马就被删除，导致再下一个请求又获取了锁。 所以我们在删除锁的时候需要做原子操作，这里Redis给我提供了一个Lua脚本使得删除锁成为了原子操作 public String getInfoFromDbWithRedisLock() { //创建分布式锁不设置唯一标识 String uuid = UUID.randomUUID().toString(); Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(\"lock\", \"uuid\", 300, TimeUnit.SECONDS); if (lock) { String info = \"\"; try { //执行业务逻辑 info = getInfoFromDB(); } finally { String script = \"if redis.call(\\\"get\\\",KEYS[1]) == ARGV[1]\\n\" + \"then\\n\" + \" return redis.call(\\\"del\\\",KEYS[1])\\n\" + \"else\\n\" + \" return 0\\n\" + \"end\"; stringRedisTemplate.execute( new DefaultRedisScript\u003cLong\u003e(script, Long.class), Arrays.asList(\"lock\"), uuid); } return info; } else { System.out.println(\"分布式锁获取失败，等待重试\"); TimeUnit.MILLISECONDS.sleep(100); return getCatalogJsonFromDBWithRedisLock(); } } 事实上Redis不推荐这种分布式锁。 ","date":"2020-12-11","objectID":"/posts/redis/redissonandspringcache/redissonandspringcache/:1:1","tags":["Redis","分布式"],"title":"关于Redis分布式锁和缓存一致性理解","uri":"/posts/redis/redissonandspringcache/redissonandspringcache/"},{"categories":[],"content":"Redisson Redis实现分布式锁的规范算法，叫Redlock。Redisson是Java版的。 public String getInfoFromDbWithRedissonLock() { RLock lock = redissonClient.getLock(\"info-lock\"); lock.lock(); String info = \"\"; try { info = getInfoFromDB(); } finally { lock.unlock(); } return info; } 使用方法很简单，配置RedissonClient加入到Spring上下文就可以注入直接获取锁了，可以传入锁的名字，这里为info-lock。 用Redisson实现分布式锁有两个优点 锁的自动续期，如果业务超长，运行期间自动锁上新的30s。不用担心业务时间长，锁自动过期被删掉 加锁的业务只要运行完成，就不会给当前锁续期，即使不手动解锁，锁默认会在30s内自动过期，不会产生死锁问题 ","date":"2020-12-11","objectID":"/posts/redis/redissonandspringcache/redissonandspringcache/:1:2","tags":["Redis","分布式"],"title":"关于Redis分布式锁和缓存一致性理解","uri":"/posts/redis/redissonandspringcache/redissonandspringcache/"},{"categories":[],"content":"Redisson Lock看门狗原理 private void lock(long leaseTime, TimeUnit unit, boolean interruptibly) throws InterruptedException private Long tryAcquire(long leaseTime, TimeUnit unit, long threadId) private \u003cT\u003e RFuture\u003cLong\u003e tryAcquireAsync(long leaseTime, TimeUnit unit, long threadId) \u003cT\u003e RFuture\u003cT\u003e tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand\u003cT\u003e command) private void scheduleExpirationRenewal(long threadId) private void renewExpiration() 按顺序翻看上面几个方法，在lock方法中有while(true)一直循环给锁续期。 来到tryAcquireAsync方法，如果设置自动解锁时间leaseTime会执行tryLockInnerAsync方法，其中只执行一次Lua脚本进行加锁，不会续期。默认超时就是我们给定的时间 当没有设置leaseTime时执行scheduleExpirationRenewal和renewExpiration重新给锁续上过期时间。lockWatchdogTimeout = 30 * 1000，看门狗默认时间30s。 并且每隔10秒都会自动的再次续期，续成30秒。internalLockLeaseTime = 看门狗时间 / 3。 ","date":"2020-12-11","objectID":"/posts/redis/redissonandspringcache/redissonandspringcache/:1:3","tags":["Redis","分布式"],"title":"关于Redis分布式锁和缓存一致性理解","uri":"/posts/redis/redissonandspringcache/redissonandspringcache/"},{"categories":[],"content":"SpringCache 为了保证缓存里的数据和数据库里的一致性而引入，同时可以简化Redis缓存代码。 关于缓存数据一致性问题： 双写模式（数据库更新时，直接写入缓存） 失效模式（数据库更新时，是缓存失效） 这两种方式在并发场景下都存在一定问题。 //代表当前方法的结果需要缓存，如果缓存中有，方法不调用。如果缓存中没有，会调用方法，最后将方法的返回值保存进缓存中 @Cacheable(value=\"info\", key=\"#root.method.name\", sync=true) public String getInfo() { return getInfoFromDB(); } //失效模式 @CacheEvict(value = \"info\", key = \"'getInfo'\") public void UpdateInfo(String info) { return update(info); } 这里value表示一个分区，key表示保存到缓存中key的名字。为了避免发生缓存击穿sync=true开启同步锁，但是翻看源码发现加的还是本地锁和上面的情况一样。 所以对于常规数据，读多写少，即时性，一致性要求不高的数据，完全可以使用SpringCache ","date":"2020-12-11","objectID":"/posts/redis/redissonandspringcache/redissonandspringcache/:1:4","tags":["Redis","分布式"],"title":"关于Redis分布式锁和缓存一致性理解","uri":"/posts/redis/redissonandspringcache/redissonandspringcache/"},{"categories":[],"content":"搭建开发环境 ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:0","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"VirtualBox 官网下载：https://www.virtualbox.org/wiki/Downloads ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:1","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"Vagrant 官网下载：https://www.vagrantup.com/downloads ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:2","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"创建虚拟机 打开cmd窗口看下Vagrant安装的如何 \u003e vagrant 初始化一个新的VM，官网上的box下载有点慢，这里在网上找了个镜像 \u003e vagrant init centos7 https://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7.box 启动VM，可以看到VirtualBox中创建了一个虚拟机 \u003e vagrant up ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:3","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"配置虚拟机 网络配置 先来看看VirtualBox的虚拟网卡 \u003e ipconfig #192.168.56.1 找到创建虚拟机时生成的Vagrantfile，C:\\Users\\ASUS大概在这个目录下，加一段话。 \u003e config.vm.network \"private_network\", ip: \"192.168.56.100\" # 这个ip需要根据上面获取的ip来配置，最后一位不为0和255，其中随便选一个。 重启下虚拟机 \u003e vagrant reload 登入ssh互相ping一下。 \u003e vagrant ssh # 默认是使用vagrant用户登入linux，可以更改为root用户方便后续操作，默认密码是vagrant 登入过后开始使用docker安装开发环境 ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:4","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"安装开发环境 Docker $ sudo yum install -y yum-utils $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo $ sudo yum install docker-ce docker-ce-cli containerd.io # 启动Docker $ sudo systemctl start docker # 设置开机自启动 $ sudo systemctl enable docker # 配置阿里云镜像加速 # 登入自己的阿里云找到镜像加速器,根据操作文档粘一下命令 MySQL # 默认下载最新，可以选取版本号mysql:5.7 $ docker pull mysql # 这里先创建一个文件夹,不然后面文件挂载当做一个目录创建了 $ mkdir /mydata/mysql/conf $ touch my.cnf # 创建实例并启动，并将文件挂载到主机 $ docker run -p 3306:3306 --privileged=true --name mysql \\ -v /mydata/mysql/conf/my.cnf:/etc/mysql/my.cnf \\ -v /mydata/mysql/conf:/etc/mysql \\ -v /mydata/mysql/logs:/var/log/mysql \\ -v /mydata/mysql/mysql-files:/var/lib/mysql-files \\ -v /mydata/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=root -d mysql # 做一下基本配置 $ vi /mydata/mysql/conf/my.cnf [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] init_connect='SET collation_connection = utf8_unicode_ci' init_connect='SET NAMES utf8' character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve # 重启 $ docker restart mysql # 设置开机启动 $ docker update mysql --restart=always mysql8.0 之前的版本中加密规则是mysql_native_password，而在mysql8之后,加密规则是caching_sha2_password。如果使用的是mysql8.0以后的版本，为了能使用远程连接还需更改一下加密方式 # 首先进入到mysql容器中 $ docker exec -it mysql /bin/bash # 登入mysql $ mysql -u root -p mysql\u003e use mysql; # 将root用户设置为所有地址可登录，原来是localhost表示只用本机可登录 mysql\u003e update user set host='%' where user='root'; # 将用户root密码设置为永不过期 mysql\u003e alter user 'root'@'%' identified by '密码' password expire never; # 将root用户密码加密方式改为mysql_native_password ，上面查到root用户密码的加密方式为caching_sha2_password mysql\u003e alter user 'root'@'%' identified with mysql_native_password by '密码'; # 刷新权限，在别的机器上即可登录 mysql\u003e flush privileges; Redis $ docker pull redis $ mkdir -p /mydata/redis/conf $ touch /mydata/redis/conf/redia.conf $ docker run -p 6379:6379 --name redis \\ -v /mydata/redis/data:/data \\ -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf # 改下配置,启动aof持久化 $ vi /mydata/redis/conf/redis.conf appendonly yes # 重启 $ docker restart redis # 设置开机启动 $ docker update redis --restart=always ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:5","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"更新 ElasticSearch $ docker pull elasticsearch:7.6.2 $ mkdir -p /mydata/elasticsearch/config $ mkdir -p /mydata/elasticsearch/data $ echo \"http.host:0.0.0.0\"\u003e\u003e/mydata/elasticsearch/config/elasticsearch.yml $ chmod -R 777 /mydata/elasticsearch/ $ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\ -e \"discovery.type=single-node\" \\ -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" \\ -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.6.2 # 设置开机启动 $ docker update elasticsearch --restart=always Kibana 可视化检索数据 $ docker pull kibana:7.6.2 $ docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.100:9200 -p 5601:5601 -d kibana:7.6.2 $ docker update kibana --restart=always RabbitMQ $ docker pull rabbitmq:management $ docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management $ docker update rabbitmq --restart=always ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:6","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"单例模式 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:0","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"常见的单例模式 饿汉式 写法简单，避免了线程同步问题。没有延迟加载，如果长时间没使用这个实例会造成空间浪费。 懒汉式 性能好，懒加载。但存在线程安全问题 懒汉式+同步方法 线程安全，懒加载。但性能差 懒汉式+同步代码块 线程不安全，性能一般 DCL+volatile 线程安全，懒加载，性能比较好 Holder单例模式 线程安全，懒加载，性能好。 枚举单例模式 线程安全，懒加载，性能好，不会被反序列化破坏。 对于前五种方式，他们虽然都能实现单例模式，但是优缺点很明显。 饿汉式：虽然并发情况下安全性高。但不能懒加载，内存消耗大。 懒汉式：能实现懒加载，虽然一步步优化并发情况下安全性得到了保证，但使用synchronized对性能有所影响。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:1","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"Holder单例模式 /** * @author kLjSumi * @Date 2020/10/24 */ public class Singleton { private Singleton() { } //在静态内部类中持有Singleton的实例，并且可以被直接初始化 private static class Holder { private static Singleton instance = new Singleton(); } //调用getInstance()方法，事实上是获得Holder的instance静态属型 public static Singleton getInstance() { return Holder.instance; } } 在外部类加载时并不需要立即加载内部类，所以内部类不被初始化则不用去初始化instance，故而实现懒加载。 当调用getInstance()时，instance被初始化。在这个初始化过程中，虚拟机会保证一个类的\u003cclinit\u003e()方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\u003cclinit\u003e ()方法，其他线程都需要阻塞等待，直到该方法执行完毕。 在调用getInstance()方法时，没有多次的去new对象而是在初始化期间只创建一次，每次取的都是Holder中的同一个对象，这点与饿汉式相同保证了单例。 但Holder单例模式也不是最完美的单例模式，由于静态内部类的形式创建单例，所以外部无法传递参数进去。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:2","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"避免反序列化对单例的破坏 /** * @author kLjSumi * @Date 2020/10/24 */ public class Singleton implements Serializable { private Singleton() { } private static class Holder { private static Singleton instance = new Singleton(); } public static Singleton getInstance() { return Holder.instance; } //反序列化时，会通过反射的方式调用该方法 private Object readResolve() { System.out.println(\"调用了readResolve()方法!\"); return Holder.instance; } } 之前讲到的所有单例模式都存在一个问题，就是一旦实现了serializable接口之后，每次调用readObject()方法，会通过反射的方式调用无参构造方法，重新创建一个对象破坏单例。可以通过定义readResolve()方法来避免。 if (obj != null \u0026\u0026 handles.lookupException(passHandle) == null \u0026\u0026 desc.hasReadResolveMethod()) { Object rep = desc.invokeReadResolve(obj); if (unshared \u0026\u0026 rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } handles.setObject(passHandle, obj = rep); } } 这部分代码选自ObjectInputStream类中的readOrdinaryObject()方法。 hasReadResolveMethod：如果实现了serializable或者externalizable接口的类中包含readResolve()方法则返回true。 invokeReadResovle()：通过反射的方式调用要被反序列化的类的readResolve()方法。 所以在Singleton中定义readResolve()方法，并指定要返回的对象的生成策略，就可以防止单例被破坏。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:3","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"枚举单例模式 /** * @author kLjSumi * @Date 2020/10/24 */ public enum Singleton { //创建一个枚举对象，该对象天生为单例 INSTANCE; public void doSomething() { System.out.println(\"doSomething\"); } } 在所有单例实现方式中， 枚举是一种在代码写法上最简单的方式。 当使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enmu类，并且其中的属性会被定义为public static final，当一个Java类第一次被使用静态资源初始化、Java类的加载和初始化过程都是现成安全的，Holder单例模式中有讲解这个初始化过程。 为了保证枚举类型像Java规范中所说的，每个枚举类型及其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊定制，所以避免了反序列化对单例的破坏。 在《Effective Java》一书中的第三条，作者Josh Bloch也提倡使用该方式来实现单例。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:4","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":["Java基础"],"content":"Java反射的一些概念","date":"2020-09-17","objectID":"/posts/reflect/reflect/","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"反射 反射：将类的各个组成部分封装为其他对象，就是反射机制 ​ 好处： ​ 1、可以在程序的运行过程中，操作这些对象 ​ 2、可以解耦，提高程序的可扩展性 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:0","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"获取class对象的方式 class.forName(“全类名”)：将字节码文件加载进内存，返回class对象 ​ 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 ​ 多用于参数传递 对象.getClass：getClass()方法在Object类中定义的 ​ 多用于对象的获取字节码的方式 结论：统一字节码文件在一次程序运行过程中只会加载一次，三种方式获取的Class对象都是同一个 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:1","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"Class对象的功能 获取功能 获取成员变量 Class\u003cUser\u003e userClass = User.class; Field[] fields = userClass.getFields(); //只获取public修饰的成员变量 Field name = userClass.getField(\"name\"); Field[] declaredFields = userClass.getDeclaredFields();//获取所有成员变量，不考虑修饰符 Field name1 = userClass.getDeclaredField(\"name\"); User user = new User(); name1.setAccessible(true); //忽略访问符权限修饰符的安全检查，暴力反射 name1.set(user,\"张三\"); //设值 name1.get(user); //取值 获取构造方法 Class\u003cUser\u003e userClass = User.class; Constructor\u003c?\u003e[] constructors = userClass.getConstructors(); Constructor\u003cUser\u003e constructor = userClass.getConstructor(String.class, Integer.class, Date.class); User user = constructor.newInstance(\"张三\", 20, new Date()); //创建对象 创建对象 T newInstance(Object… initargs) 获取成员方法 Class\u003cUser\u003e userClass = User.class; Method[] methods = userClass.getMethods(); Method setName = userClass.getMethod(\"setName\", String.class); User user = userClass.newInstance(); getName.invoke(user,\"张三\"); //执行该方法 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:2","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["JVM"],"content":"emmm....","date":"2020-09-16","objectID":"/posts/first_post/","tags":["JVM"],"title":"intern()方法的作用","uri":"/posts/first_post/"},{"categories":["JVM"],"content":"intern() 如果字符串常量池中没有对应的字符串的话，则在常量池中生成，并将引用地址改为常量池。如果存在就返回字符串， 保证变量s指向的是字符串常量池中的数据（另一种方式String s = “abc”） String s = new String(\"1\"); s.intern(); //常量池中已经存在\"1\"，s还是指向堆中的对象 String s2 = \"1\"; System.out.println(s == s2); //jdk6:false jdk7/jdk8:false String s3 = new String(\"1\") + new String(\"1\"); s3.intern(); //常量池中不存在\"11\"，生成后s3指向常量池 String s4 = \"11\"; System.out.println(s3 == s4); //jdk6:false jdk7/jdk8:true 题目1：new String(\"ab\")会创建几个对象 两个对象，看字节码就知道了 一个对象是：new关键字在堆空间中创建的 另一个对象是：字符串常量池中的对象 题目2：new String(\"a\") + new String(\"b\")会创建几个对象 对象1：new StringBuilder() 对象2：new String() 对象3：常量池中的\"a\" 对象4：new String() 对象5：常量池中的\"b\" StringBuilder的toString方法生成对象6 对象6：new String(\"ab\") toString()的调用，在字符串常量池中，没有生成\"ab\" ","date":"2020-09-16","objectID":"/posts/first_post/:1:0","tags":["JVM"],"title":"intern()方法的作用","uri":"/posts/first_post/"}]