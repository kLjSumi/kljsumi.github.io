[{"categories":[],"content":"Vagrant导致磁盘占用100%，无法使用Docker拉取镜像","date":"2020-11-20","objectID":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/","tags":["Linux","Docker"],"title":"Docker磁盘占用100%","uri":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/"},{"categories":[],"content":"背景 之前使用VirtualBox+Vagrant搭建了一个虚拟机，使用Docker下载了Mysql和Redis点击这里。这次需要安装一个ElasticSearch,和之前一样我使用docker pull。但是镜像却怎么也下载不下来，明明进度条已经下载满了，却始终不显示compelete,进度条一直显示在那儿，最后报错说docker tls handshake timeout。于是换了几个国内镜像还是不行，我想可能是我的网络真的不行，我换了个网重来一遍这次报错终于发现了问题：no space left on device，磁盘容量没了。 ","date":"2020-11-20","objectID":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/:0:1","tags":["Linux","Docker"],"title":"Docker磁盘占用100%","uri":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/"},{"categories":[],"content":"清理磁盘 虚拟机创建时毕竟有40G的磁盘，我才下了两个镜像怎么就会磁盘空间不足了呢，于是开始清理磁盘。 #查看下磁盘占用 $ df -h 根据网上的办法我开始来清理Docker无用的数据 $ docker system prune -a 执行之后，发现虽然清理了2个多G的数据，显然这个问题。 然后我进入了/var/lib/docker/overlay2这个目录发现里面的文件并不大。 之后看到别人说其实和overlay没关系（它的usage和真实的disk usage相同），它只是一个docker的虚拟文件系统，真实的文件系统是前者/dev/sdal， 那么它对应的是更目录 /。这下知道要去根目录下找垃圾，哈哈。 抓狂了一会儿后，开始找其他的办法。直接查看/下的大文件都放在哪了 # 查找\"/\"目录下所有大于100M的所有文件 $ find / -type f -size +100M -print0 | xargs -0 du -h | sort -nr 这时候可以看到打印的文件大部分来自/vagrant/AppData/Local这个目录下。这下明白了是Vagrant的锅。 ","date":"2020-11-20","objectID":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/:0:2","tags":["Linux","Docker"],"title":"Docker磁盘占用100%","uri":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/"},{"categories":[],"content":"原因 vagrant提供了将本机目录挂载到虚拟机目录下的功能，默认是将vagrant配置文件所在目录挂载到虚拟机/vagrant目录下 所以一气之下把这个目录下的文件全删了，这下再来一次df -h就能看到上图了，这下舒服了。 ","date":"2020-11-20","objectID":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/:0:3","tags":["Linux","Docker"],"title":"Docker磁盘占用100%","uri":"/posts/linux/vagrant_full_capacity/vagrant_full_capacity/"},{"categories":[],"content":"搭建开发环境 ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:0","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"VirtualBox 官网下载：https://www.virtualbox.org/wiki/Downloads ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:1","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"Vagrant 官网下载：https://www.vagrantup.com/downloads ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:2","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"创建虚拟机 打开cmd窗口看下Vagrant安装的如何 \u003e vagrant 初始化一个新的VM，官网上的box下载有点慢，这里在网上找了个镜像 \u003e vagrant init centos7 https://mirrors.ustc.edu.cn/centos-cloud/centos/7/vagrant/x86_64/images/CentOS-7.box 启动VM，可以看到VirtualBox中创建了一个虚拟机 \u003e vagrant up ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:3","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"配置虚拟机 网络配置 先来看看VirtualBox的虚拟网卡 \u003e ipconfig #192.168.56.1 找到创建虚拟机时生成的Vagrantfile，C:\\Users\\ASUS大概在这个目录下，加一段话。 \u003e config.vm.network \"private_network\", ip: \"192.168.56.100\" # 这个ip需要根据上面获取的ip来配置，最后一位不为0和255，其中随便选一个。 重启下虚拟机 \u003e vagrant reload 登入ssh互相ping一下。 \u003e vagrant ssh # 默认是使用vagrant用户登入linux，可以更改为root用户方便后续操作，默认密码是vagrant 登入过后开始使用docker安装开发环境 ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:4","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"安装开发环境 Docker $ sudo yum install -y yum-utils $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo $ sudo yum install docker-ce docker-ce-cli containerd.io # 启动Docker $ sudo systemctl start docker # 设置开机自启动 $ sudo systemctl enable docker # 配置阿里云镜像加速 # 登入自己的阿里云找到镜像加速器,根据操作文档粘一下命令 MySQL # 默认下载最新，可以选取版本号mysql:5.7 $ docker pull mysql # 这里先创建一个文件夹,不然后面文件挂载当做一个目录创建了 $ mkdir /mydata/mysql/conf $ touch my.cnf # 创建实例并启动，并将文件挂载到主机 $ docker run -p 3306:3306 --privileged=true --name mysql \\ -v /mydata/mysql/conf/my.cnf:/etc/mysql/my.cnf \\ -v /mydata/mysql/conf:/etc/mysql \\ -v /mydata/mysql/logs:/var/log/mysql \\ -v /mydata/mysql/mysql-files:/var/lib/mysql-files \\ -v /mydata/mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=root -d mysql # 做一下基本配置 $ vi /mydata/mysql/conf/my.cnf [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] init_connect='SET collation_connection = utf8_unicode_ci' init_connect='SET NAMES utf8' character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve # 重启 $ docker restart mysql # 设置开机启动 $ docker update mysql --restart=always mysql8.0 之前的版本中加密规则是mysql_native_password，而在mysql8之后,加密规则是caching_sha2_password。如果使用的是mysql8.0以后的版本，为了能使用远程连接还需更改一下加密方式 # 首先进入到mysql容器中 $ docker exec -it mysql /bin/bash # 登入mysql $ mysql -u root -p mysql\u003e use mysql; # 将root用户设置为所有地址可登录，原来是localhost表示只用本机可登录 mysql\u003e update user set host='%' where user='root'; # 将用户root密码设置为永不过期 mysql\u003e alter user 'root'@'%' identified by '密码' password expire never; # 将root用户密码加密方式改为mysql_native_password ，上面查到root用户密码的加密方式为caching_sha2_password mysql\u003e alter user 'root'@'%' identified with mysql_native_password by '密码'; # 刷新权限，在别的机器上即可登录 mysql\u003e flush privileges; Redis $ docker pull redis $ mkdir -p /mydata/redis/conf $ touch /mydata/redis/conf/redia.conf $ docker run -p 6379:6379 --name redis \\ -v /mydata/redis/data:/data \\ -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -d redis redis-server /etc/redis/redis.conf # 改下配置,启动aof持久化 $ vi /mydata/redis/conf/redis.conf appendonly yes # 重启 $ docker restart redis # 设置开机启动 $ docker update redis --restart=always ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:5","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"更新 ElasticSearch $ docker pull elasticsearch:7.6.2 $ mkdir -p /mydata/elasticsearch/config $ mkdir -p /mydata/elasticsearch/data $ echo \"http.host:0.0.0.0\"\u003e\u003e/mydata/elasticsearch/config/elasticsearch.yml $ chmod -R 777 /mydata/elasticsearch/ $ docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\ -e \"discovery.type=single-node\" \\ -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" \\ -v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\ -v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\ -v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\ -d elasticsearch:7.6.2 # 设置开机启动 $ docker update elasticsearch --restart=always Kibana 可视化检索数据 $ docker pull kibana:7.6.2 $ docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.100:9200 -p 5601:5601 -d kibana:7.6.2 $ docker update kibana --restart=always ","date":"2020-10-27","objectID":"/posts/linux/create/create/:1:6","tags":["docker","linux"],"title":"第一次使用Docker","uri":"/posts/linux/create/create/"},{"categories":[],"content":"单例模式 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:0","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"常见的单例模式 饿汉式 写法简单，避免了线程同步问题。没有延迟加载，如果长时间没使用这个实例会造成空间浪费。 懒汉式 性能好，懒加载。但存在线程安全问题 懒汉式+同步方法 线程安全，懒加载。但性能差 懒汉式+同步代码块 线程不安全，性能一般 DCL+volatile 线程安全，懒加载，性能比较好 Holder单例模式 线程安全，懒加载，性能好。 枚举单例模式 线程安全，懒加载，性能好，不会被反序列化破坏。 对于前五种方式，他们虽然都能实现单例模式，但是优缺点很明显。 饿汉式：虽然并发情况下安全性高。但不能懒加载，内存消耗大。 懒汉式：能实现懒加载，虽然一步步优化并发情况下安全性得到了保证，但使用synchronized对性能有所影响。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:1","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"Holder单例模式 /** * @author kLjSumi * @Date 2020/10/24 */ public class Singleton { private Singleton() { } //在静态内部类中持有Singleton的实例，并且可以被直接初始化 private static class Holder { private static Singleton instance = new Singleton(); } //调用getInstance()方法，事实上是获得Holder的instance静态属型 public static Singleton getInstance() { return Holder.instance; } } 在外部类加载时并不需要立即加载内部类，所以内部类不被初始化则不用去初始化instance，故而实现懒加载。 当调用getInstance()时，instance被初始化。在这个初始化过程中，虚拟机会保证一个类的\u003cclinit\u003e()方法在多线程环境中被正确地加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的\u003cclinit\u003e ()方法，其他线程都需要阻塞等待，直到该方法执行完毕。 在调用getInstance()方法时，没有多次的去new对象而是在初始化期间只创建一次，每次取的都是Holder中的同一个对象，这点与饿汉式相同保证了单例。 但Holder单例模式也不是最完美的单例模式，由于静态内部类的形式创建单例，所以外部无法传递参数进去。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:2","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"避免反序列化对单例的破坏 /** * @author kLjSumi * @Date 2020/10/24 */ public class Singleton implements Serializable { private Singleton() { } private static class Holder { private static Singleton instance = new Singleton(); } public static Singleton getInstance() { return Holder.instance; } //反序列化时，会通过反射的方式调用该方法 private Object readResolve() { System.out.println(\"调用了readResolve()方法!\"); return Holder.instance; } } 之前讲到的所有单例模式都存在一个问题，就是一旦实现了serializable接口之后，每次调用readObject()方法，会通过反射的方式调用无参构造方法，重新创建一个对象破坏单例。可以通过定义readResolve()方法来避免。 if (obj != null \u0026\u0026 handles.lookupException(passHandle) == null \u0026\u0026 desc.hasReadResolveMethod()) { Object rep = desc.invokeReadResolve(obj); if (unshared \u0026\u0026 rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } handles.setObject(passHandle, obj = rep); } } 这部分代码选自ObjectInputStream类中的readOrdinaryObject()方法。 hasReadResolveMethod：如果实现了serializable或者externalizable接口的类中包含readResolve()方法则返回true。 invokeReadResovle()：通过反射的方式调用要被反序列化的类的readResolve()方法。 所以在Singleton中定义readResolve()方法，并指定要返回的对象的生成策略，就可以防止单例被破坏。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:3","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":[],"content":"枚举单例模式 /** * @author kLjSumi * @Date 2020/10/24 */ public enum Singleton { //创建一个枚举对象，该对象天生为单例 INSTANCE; public void doSomething() { System.out.println(\"doSomething\"); } } 在所有单例实现方式中， 枚举是一种在代码写法上最简单的方式。 当使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enmu类，并且其中的属性会被定义为public static final，当一个Java类第一次被使用静态资源初始化、Java类的加载和初始化过程都是现成安全的，Holder单例模式中有讲解这个初始化过程。 为了保证枚举类型像Java规范中所说的，每个枚举类型及其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊定制，所以避免了反序列化对单例的破坏。 在《Effective Java》一书中的第三条，作者Josh Bloch也提倡使用该方式来实现单例。 ","date":"2020-10-24","objectID":"/posts/singleton/singleton/:1:4","tags":["Java","设计模式"],"title":"理解Holder和枚举单例模式","uri":"/posts/singleton/singleton/"},{"categories":["Java基础"],"content":"Java反射的一些概念","date":"2020-09-17","objectID":"/posts/reflect/reflect/","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"反射 反射：将类的各个组成部分封装为其他对象，就是反射机制 ​ 好处： ​ 1、可以在程序的运行过程中，操作这些对象 ​ 2、可以解耦，提高程序的可扩展性 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:0","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"获取class对象的方式 class.forName(“全类名”)：将字节码文件加载进内存，返回class对象 ​ 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 类名.class：通过类名的属性class获取 ​ 多用于参数传递 对象.getClass：getClass()方法在Object类中定义的 ​ 多用于对象的获取字节码的方式 结论：统一字节码文件在一次程序运行过程中只会加载一次，三种方式获取的Class对象都是同一个 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:1","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["Java基础"],"content":"Class对象的功能 获取功能 获取成员变量 Class\u003cUser\u003e userClass = User.class; Field[] fields = userClass.getFields(); //只获取public修饰的成员变量 Field name = userClass.getField(\"name\"); Field[] declaredFields = userClass.getDeclaredFields();//获取所有成员变量，不考虑修饰符 Field name1 = userClass.getDeclaredField(\"name\"); User user = new User(); name1.setAccessible(true); //忽略访问符权限修饰符的安全检查，暴力反射 name1.set(user,\"张三\"); //设值 name1.get(user); //取值 获取构造方法 Class\u003cUser\u003e userClass = User.class; Constructor\u003c?\u003e[] constructors = userClass.getConstructors(); Constructor\u003cUser\u003e constructor = userClass.getConstructor(String.class, Integer.class, Date.class); User user = constructor.newInstance(\"张三\", 20, new Date()); //创建对象 创建对象 T newInstance(Object… initargs) 获取成员方法 Class\u003cUser\u003e userClass = User.class; Method[] methods = userClass.getMethods(); Method setName = userClass.getMethod(\"setName\", String.class); User user = userClass.newInstance(); getName.invoke(user,\"张三\"); //执行该方法 ","date":"2020-09-17","objectID":"/posts/reflect/reflect/:1:2","tags":["Java"],"title":"Java反射","uri":"/posts/reflect/reflect/"},{"categories":["JVM"],"content":"emmm....","date":"2020-09-16","objectID":"/posts/first_post/","tags":["JVM"],"title":"intern()方法的作用","uri":"/posts/first_post/"},{"categories":["JVM"],"content":"intern() 如果字符串常量池中没有对应的字符串的话，则在常量池中生成，并将引用地址改为常量池。如果存在就返回字符串， 保证变量s指向的是字符串常量池中的数据（另一种方式String s = “abc”） String s = new String(\"1\"); s.intern(); //常量池中已经存在\"1\"，s还是指向堆中的对象 String s2 = \"1\"; System.out.println(s == s2); //jdk6:false jdk7/jdk8:false String s3 = new String(\"1\") + new String(\"1\"); s3.intern(); //常量池中不存在\"11\"，生成后s3指向常量池 String s4 = \"11\"; System.out.println(s3 == s4); //jdk6:false jdk7/jdk8:true 题目1：new String(\"ab\")会创建几个对象 两个对象，看字节码就知道了 一个对象是：new关键字在堆空间中创建的 另一个对象是：字符串常量池中的对象 题目2：new String(\"a\") + new String(\"b\")会创建几个对象 对象1：new StringBuilder() 对象2：new String() 对象3：常量池中的\"a\" 对象4：new String() 对象5：常量池中的\"b\" StringBuilder的toString方法生成对象6 对象6：new String(\"ab\") toString()的调用，在字符串常量池中，没有生成\"ab\" ","date":"2020-09-16","objectID":"/posts/first_post/:1:0","tags":["JVM"],"title":"intern()方法的作用","uri":"/posts/first_post/"}]